#!/usr/bin/env python3

# This file is part of Cockpit.
#
# Copyright (C) 2016-2024 Red Hat, Inc.
#
# Cockpit is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# Cockpit is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Cockpit; If not, see <http://www.gnu.org/licenses/>.

import argparse
import json
import os
import shlex
import subprocess
import sys

import task
from lib import testmap
from lib.constants import BOTS_DIR, SCRIPTS_DIR


def run(*cmd, check: bool = True, **kwargs) -> int:
    print('\n+', shlex.join(cmd), file=sys.stderr)
    result = subprocess.run(cmd, **kwargs, check=check)
    return result.returncode


def get_upstream() -> tuple[str, str]:
    try:
        output = subprocess.check_output(('git', 'rev-parse', '--abbrev-ref', '@{upstream}'), text=True)
    except subprocess.CalledProcessError:
        output = ''

    parts = output.strip().split('/')
    if len(parts) == 2:
        return parts[0], parts[1]
    else:
        return ('origin', 'main')


def image_refresh(image: str, *, propose: bool, dry_run: bool, log: str | None) -> None:
    triggers = testmap.tests_for_image(image)

    # Cleanup any extraneous disk usage elsewhere
    run('./vm-reset')

    # download the current image, for comparing them; that may not exist yet for newly introduced images
    if run('./image-download', image, check=False) == 0:
        old_image = f'{BOTS_DIR}/images/{image}'
    else:
        old_image = None

    # create the new image
    run('./image-create', '--verbose', '--capture-console', image, env={**os.environ, 'VIRT_BUILDER_NO_CACHE': "yes"})

    # upload the new image
    if dry_run:
        task.would('./image-upload', '--prune-s3', image)
    else:
        run('./image-upload', '--prune-s3', image)

    # compare it to the previous one (on hosts we can ssh to)
    if old_image and os.path.exists(f'{SCRIPTS_DIR}/{image}.setup'):
        run('./image-diff', old_image, image)

    # create branch and push it
    branch = task.branch(name='image-refresh', context=image, pathspec='images',
                         message=f'images: Update {image} image', dry=dry_run)

    if propose:
        # propose a pull request
        pull = task.pull(
            branch, title=f'Image refresh for {image}', body=f'Log: {log}' if log else None, dry=dry_run
        )

        # magic: post this log as a status on the new pull request
        if log is not None:
            log_status = {
                'context': f'image-refresh/{image}',
                'state': 'success',
                'description': 'Forwarded status',
                'target_url': log
            }

            if dry_run:
                task.would('post status:', json.dumps(log_status, indent=4))
            else:
                task.api.post(f"statuses/{pull['head']['sha']}", log_status)

        # Trigger this pull request
        if dry_run:
            task.would('trigger tests:', json.dumps(triggers, indent=4))
        else:
            head = pull["head"]["sha"]
            for trigger in triggers:
                status = {"state": "pending", "context": context, "description": github.NOT_TESTED_DIRECT}
                task.api.post(f"statuses/{head}", status)


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument('--dry-run', '-n', action='store_true', help="Don't actually upload, push, or propose")
    parser.add_argument('--propose', action='store_true', help="After pushing the branch, propose it as a PR")
    parser.add_argument('--log', help="Link to this log URL when proposing [default: COCKPIT_CI_LOG_URL]")
    parser.add_argument('image', help="Name of the image to refresh")
    args = parser.parse_args()

    try:  # set -e
        image_refresh(
            image=args.image,
            propose=args.propose,
            dry_run=args.dry_run,
            log=args.log or os.environ.get('COCKPIT_CI_LOG_URL')
        )
    except subprocess.CalledProcessError as exc:
        sys.exit(f'Exit status {exc.returncode} from {exc.cmd!r}')


if __name__ == '__main__':
    main()
