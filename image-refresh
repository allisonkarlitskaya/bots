#!/usr/bin/env python3

# This file is part of Cockpit.
#
# Copyright (C) 2016-2024 Red Hat, Inc.
#
# Cockpit is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# Cockpit is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Cockpit; If not, see <http://www.gnu.org/licenses/>.

import argparse
import json
import os
import re
import shlex
import subprocess
import sys
from datetime import datetime, timezone

from lib import testmap
from lib.constants import BOTS_DIR, SCRIPTS_DIR
from task import github


def run(*cmd, check: bool = True, **kwargs) -> int:
    print('\n+', shlex.join(cmd), file=sys.stderr)
    result = subprocess.run(cmd, **kwargs, check=check)
    return result.returncode


def get_upstream() -> tuple[str, str]:
    try:
        output = subprocess.check_output(('git', 'rev-parse', '--abbrev-ref', '@{upstream}'), text=True)
    except subprocess.CalledProcessError:
        output = ''

    parts = output.strip().split('/')
    if len(parts) == 2:
        return parts[0], parts[1]
    else:
        return ('origin', 'main')


def image_refresh(image: str, *, propose: bool, dry_run: bool) -> None:
    # Cleanup any extraneous disk usage elsewhere
    run('./vm-reset')

    # download the current image, for comparing them; that may not exist yet for newly introduced images
    if run('./image-download', image, check=False) == 0:
        old_image = f'{BOTS_DIR}/images/{image}'
    else:
        old_image = None

    # create the new image
    run('./image-create', '--verbose', '--capture-console', image, env={**os.environ, 'VIRT_BUILDER_NO_CACHE': "yes"})

    # upload the new image
    if dry_run:
        print('\n** Would upload the image')
    else:
        run('./image-upload', '--prune-s3', image)

    # compare it to the previous one (on hosts we can ssh to)
    if old_image and os.path.exists(f'{SCRIPTS_DIR}/{image}.setup'):
        run('./image-diff', old_image, image)

    # commit the new image
    run('git', 'commit', '-m', f'images: Update {image} image', f'images/{image}')

    # choose a branch name
    branch = f'image-refresh-{image}-{datetime.now(timezone.utc):%Y%m%d-%H%M%S}'
    branch = re.sub('[^A-Za-z0-9]+', '-', branch)

    # "what would push do?"
    remote, base = get_upstream()
    if dry_run:
        print(f'\n** Would push to branch `{branch}` on `{remote}`')
    else:
        run('git', 'push', remote, f'+HEAD:refs/heads/{branch}')

    if propose:
        repo = github.get_origin_repo(remote)
        api = github.GitHub(repo=repo)

        data = {
            'title': f'Image refresh for {image}',
            'body': f'Image refresh for {image}',
            'head': branch,
            'base': base,
        }

        if dry_run:
            print(f'\n** Would propose a PR against `{api.repo}:{base}`:')
            print(json.dumps(data, indent=4))
        else:
            api.post('pulls', data)

        triggers = testmap.tests_for_image(image)
        head = subprocess.check_output(('git', 'rev-parse', 'HEAD'), text=True).strip()
        if dry_run:
            print(f'\n** Would trigger statuses on {head}:', json.dumps(triggers, indent=4))
        else:
            for context in triggers:
                status = {"state": "pending", "context": context, "description": github.NOT_TESTED_DIRECT}
                api.post(f"statuses/{head}", status)


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument('--dry-run', '-n', action='store_true', help="Don't actually upload, push, or propose")
    parser.add_argument('--propose', action='store_true', help="After pushing the branch, propose it as a PR")
    parser.add_argument('image', help="Name of the image to refresh")
    args = parser.parse_args()

    try:  # set -e
        image_refresh(image=args.image, propose=args.propose, dry_run=args.dry_run)
    except subprocess.CalledProcessError as exc:
        sys.exit(f'Exit status {exc.returncode} from {exc.cmd!r}')


if __name__ == '__main__':
    main()
